% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{rescaleAgeGroups}
\alias{rescaleAgeGroups}
\title{Rescale counts in age groups to match counts in different age groups}
\usage{
rescaleAgeGroups(
  Value1,
  AgeInt1,
  Value2,
  AgeInt2,
  splitfun = splitUniform,
  recursive = FALSE,
  tol = 0.001
)
}
\arguments{
\item{Value1}{numeric vector. A vector of demographic counts for population
1.}

\item{AgeInt1}{integer vector. Age interval widths for population 1.}

\item{Value2}{numeric vector. A vector of demographic counts for population
2.}

\item{AgeInt2}{integer vector. Age interval widths for population 2.}

\item{splitfun}{function to use for splitting \code{pop1}. Presently on
\code{splitUniform()} works.}

\item{recursive}{logical. Shall we repeat the split/regroup/rescale process
until stable? See details. Default \code{FALSE}.}

\item{tol}{numeric. Default 1e-3. The numerical tolerance for the residual.
Used to detect stability if \code{recursive = TRUE}.}
}
\description{
This method rescales a vector of counts in arbitrary (integer) age groups to
approximate a vector of counts in a potentially different age grouping.
Common use cases will be to scale single ages (whose age pattern we wish to
roughly maintain) to sum to abridged or 5-year age groups from another
source. The counts to be rescaled could potentially be in any grouping (see
example).
}
\details{
If the final age group is open, define its age interval as 1.

Presently the intermediate splitting function assumes that counts inside the
age groups of population 1 are uniformly distributed, although this may be
relaxed if other methods become available whose behavior matches that of
\code{splitUniform()}. \code{splitMono()} will be modified soon to be
applicable here.

The method is an original contribution. It works by first splitting the
counts of \code{Value1} to single ages using the assumptions of
\code{splitfun()}, which presently only works for \code{splitUniform()}.
\code{Value1} is then rescaled such that were it re-grouped to match the age
classes of \code{Value2} they would be identical. If
\code{recursive = FALSE}, the single-age rescaled \code{Value1} data are
returned regrouped to their original ages. If \code{recursive = TRUE}, the
process is repeated until \code{Value1} is rescaled such that it could be
split and regrouped to \code{Value2} using the same process a single time
with no need for further rescaling. If age groups in \code{Value1} are very
irregular, \code{recursive = TRUE} can induce noise (see example). If the age
groups of \code{Value1} nest cleanly within the age groups of \code{Value2}
then recursion is unnecessary. This is the case, for example, whenever
\code{Value1} is in single ages and \code{Value2} is in grouped ages, which
is likely the most common usage scenario.
}
